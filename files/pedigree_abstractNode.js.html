<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>pedigree&#x2F;abstractNode.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AbstractHoverbox.html">AbstractHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/AbstractNode.html">AbstractNode</a></li>
            
                <li><a href="..&#x2F;classes/AbstractNodeVisuals.html">AbstractNodeVisuals</a></li>
            
                <li><a href="..&#x2F;classes/AbstractPerson.html">AbstractPerson</a></li>
            
                <li><a href="..&#x2F;classes/AbstractPersonVisuals.html">AbstractPersonVisuals</a></li>
            
                <li><a href="..&#x2F;classes/ActionStack.html">ActionStack</a></li>
            
                <li><a href="..&#x2F;classes/Graph.html">Graph</a></li>
            
                <li><a href="..&#x2F;classes/GroupHoverbox.html">GroupHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/Legend.html">Legend</a></li>
            
                <li><a href="..&#x2F;classes/NodeMenu.html">NodeMenu</a></li>
            
                <li><a href="..&#x2F;classes/NodetypeSelectionBubble.html">NodetypeSelectionBubble</a></li>
            
                <li><a href="..&#x2F;classes/Partnership.html">Partnership</a></li>
            
                <li><a href="..&#x2F;classes/PartnershipHoverbox.html">PartnershipHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/PartnershipVisuals.html">PartnershipVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PedigreeEditor.html">PedigreeEditor</a></li>
            
                <li><a href="..&#x2F;classes/Person.html">Person</a></li>
            
                <li><a href="..&#x2F;classes/PersonGroup.html">PersonGroup</a></li>
            
                <li><a href="..&#x2F;classes/PersonGroupVisuals.html">PersonGroupVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PersonHoverbox.html">PersonHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/PersonVisuals.html">PersonVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PlaceHolder.html">PlaceHolder</a></li>
            
                <li><a href="..&#x2F;classes/PlaceHolderVisuals.html">PlaceHolderVisuals</a></li>
            
                <li><a href="..&#x2F;classes/Pregnancy.html">Pregnancy</a></li>
            
                <li><a href="..&#x2F;classes/PregnancyVisuals.html">PregnancyVisuals</a></li>
            
                <li><a href="..&#x2F;classes/SaveLoadEngine.html">SaveLoadEngine</a></li>
            
                <li><a href="..&#x2F;classes/SaveLoadIndicator.html">SaveLoadIndicator</a></li>
            
                <li><a href="..&#x2F;classes/TemplateSelector.html">TemplateSelector</a></li>
            
                <li><a href="..&#x2F;classes/Workspace.html">Workspace</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: pedigree&#x2F;abstractNode.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * AbstractNode is the general abstract class for nodes on the Pedigree graph. An AbstractNode contains information
 * about its position on the canvas and about relationships with other nodes on the graph.
 *
 * @class AbstractNode
 * @constructor
 * @param {Number} x The x coordinate on the canvas
 * @param {Number} y The y coordinate on the canvas
 * @param {Number} [id] The id of the node
 *&#x2F;

var AbstractNode = Class.create( {

    initialize: function(x, y, id) {
        !this._type &amp;&amp; (this._type = &quot;AbstractNode&quot;);
        this._id = id ? id : editor.getGraph().generateID();
        this._graphics = this._generateGraphics(x, y);
    },
    
    &#x2F;**
     * Returns the unique ID of this node
     *
     * @method getID
     * @return {Number} the id of the node
     *&#x2F;
    getID: function() {
        return this._id;
    },

    &#x2F;**
     * Generates an instance of AbstractNodeVisuals
     *
     * @method _generateGraphics
     * @param {Number} x The x coordinate of the node
     * @param {Number} y The y coordinate of the node
     * @return {AbstractNodeVisuals}
     * @private
     *&#x2F;
    _generateGraphics: function(x, y) {
        return new AbstractNodeVisuals(this, x, y);
    },

    &#x2F;**
     * Returns the object responsible for managing graphics
     *
     * @method getGraphics
     * @return {AbstractNodeVisuals}
     *&#x2F;
    getGraphics: function() {
        return this._graphics;
    },

    &#x2F;**
     * Returns the X coordinate of the node on the canvas
     *
     * @method getX
     * @return {Number} the x coordinate
     *&#x2F;
    getX: function() {
        return this.getGraphics().getX();
    },

    &#x2F;**
     * Changes the X coordinate of the node
     *
     * @method setX
     * @param {Number} x The x coordinate on the canvas
     * @param {Boolean} [animate] Set to true if you want to animate the transition
     * @param {Function} [callback] The function called at the end of the animation
     *&#x2F;
    setX: function(x, animate, callback) {
        this.getGraphics().setX(x, animate, callback)
    },

    &#x2F;**
     * Returns the Y coordinate of the node on the canvas
     *
     * @method getY
     * @return {Number} the y coordinate
     *&#x2F;
    getY: function() {
        return this.getGraphics().getY();
    },

    &#x2F;**
     * Changes the Y coordinate of the node
     *
     * @method setY
     * @param {Number} y The x coordinate on the canvas
     * @param {Boolean} [animate] Set to true if you want to animate the transition
     * @param {Function} [callback] The function called at the end of the animation
     *&#x2F;
    setY: function(y, animate, callback) {
        this.getGraphics().setY(y, animate, callback)
    },

    &#x2F;**
     * Returns an array containing the x and y coordinates of the node on canvas.
     *
     * @method getPos
     * @return {Array} Array in the form of [x, y]
     *&#x2F;
    getPos: function() {
        return [this.getX(), this.getY()];
    },

    &#x2F;**
     * Changes the position of the node to (x,y)
     *
     * @method setPos
     * @param {Number} x The x coordinate on the canvas
     * @param {Number} y The y coordinate on the canvas
     * @param {Boolean} [animate] Set to true if you want to animate the transition
     * @param {Function} [callback] The function called at the end of the animation
     *&#x2F;
    setPos: function(x,y, animate, callback) {
        this.getGraphics().setPos(x, y, animate, callback);
    },
    
    &#x2F;**
     * Returns the type of this node
     *
     * @method getType
     * @return {String} The type (eg. &quot;Partnership&quot;, &quot;Person&quot;, etc)
     *&#x2F;
    getType: function() {
        return this._type;
    },

    &#x2F;**
     * Returns an array of all adjacent nodes (neighbors).
     *
     * @method getNeighbors
     * @return {Array} in the form of [node1, node2, ...]
     *&#x2F;
    getNeighbors: function() {
        return (this.getLowerNeighbors().concat(this.getSideNeighbors())).concat(this.getUpperNeighbors());
    },

    &#x2F;**
     * Returns an array of all adjacent nodes (neighbors) located below this node.
     *
     * @method getLowerNeighbors
     * @return {Array} in the form of [node1, node2, ...]
     *&#x2F;
    getLowerNeighbors: function() {
        return [];
    },

    &#x2F;**
     * Returns an array of all adjacent nodes (neighbors) located on the sides of this node.
     *
     * @method getSideNeighbors
     * @return {Array} in the form of [node1, node2, ...]
     *&#x2F;
    getSideNeighbors: function() {
        return [];
    },

    &#x2F;**
     * Returns an array of all adjacent nodes (neighbors) located above this node.
     *
     * @method getUpperNeighbors
     * @return {Array} in the form of [node1, node2, ...]
     *&#x2F;
    getUpperNeighbors: function() {
        return [];
    },

    &#x2F;**
     * Breaks connections with related nodes and removes the node and its visuals.
     *
     * @method remove
     * @param [isRecursive=false] {Boolean} if true, will remove all nodes that will end up disconnected from the
     * Proband
     * @param [skipConfirmation=false] {Boolean} if true, no confirmation box will pop up
     * @return {Object} in the form
     *
         {
            confirmed: true&#x2F;false,
            affected: {
                PersonNodes : [Person1, Person2, ...],
                PartnershipNodes : [Partnership1, Partnership2, ...],
                PregnancyNodes : [Pregnancy1, Pregnancy2, ...],
                PersonGroupNodes : [PersonGroup1, PersonGroup2, ...],
                PlaceHolderNodes : [PlaceHolder1, PlaceHolder2, ...]
            },
            created: [PlaceHolder1, PlaceHolder2, ...]
         }
     *&#x2F;
    remove: function(isRecursive, skipConfirmation) {
        var me = this;
        var toRemove = [];
        var affectedNeighbors = [];
        var nodes = {
            PersonNodes : [],
            PartnershipNodes : [],
            PregnancyNodes : [],
            PersonGroupNodes : [],
            PlaceHolderNodes : []
        };
        if(isRecursive) {
            toRemove.push(me.getID());
            this.getNeighbors().each(function(neighbor) {
                var result = neighbor.isRelatedTo(1, toRemove.clone());
                if(!result[0]) {
                    toRemove = result[1];
                }
                else if(neighbor.getType() == &quot;Partnership&quot;) {
                    affectedNeighbors.push(neighbor.getID());
                    neighbor.getPregnancies().each(function(preg) {
                        affectedNeighbors.push(preg.getID());
                        if(preg.isPlaceHolderPregnancy()) {
                            preg.getChildren().forEach(function(child) {
                                affectedNeighbors.push(child.getID());
                            })
                        }
                    });
                }
                else if(neighbor.getType() == &quot;Pregnancy&quot;) {
                    affectedNeighbors.push(neighbor.getID());
                    if(neighbor.isPlaceHolderPregnancy()) {
                        neighbor.getChildren().forEach(function(child){
                            affectedNeighbors.push(child.getID());
                        });
                    }
                }
            });
            var confirmation = true;
            if(!skipConfirmation) {
                toRemove.each(function(id) {
                    var node = editor.getGraph().getNodeMap()[id];
                    node &amp;&amp; node.getGraphics().getHighlightBox &amp;&amp; node.getGraphics().highlight();
                });
                if(toRemove.length &gt; 1) {
                    confirmation = confirm(&quot;Removing this person will also remove all the highlighted individuals. Are you sure you want to proceed?&quot;);
                }
                else {
                    confirmation = confirm(&quot;Removing this person will also remove all the related connections. Are you sure you want to proceed?&quot;);
                }
            }
            if(confirmation) {
                toRemove.concat(affectedNeighbors).each(function(nodeID) {
                    var node = editor.getGraph().getNodeMap()[nodeID];
                    node &amp;&amp; nodes[node.getType() + &quot;Nodes&quot;].push(node.getInfo());
                });
                var placeholders = [];
                toRemove.forEach(function(id) {
                    var node = editor.getGraph().getNodeMap()[id];
                    if(node) {
                        var ph = node.remove(false).created[0];
                        if(id == me.getID()) {
                            ph &amp;&amp; placeholders.push(ph);
                        }
                        else if(ph) {
                            var placeholder = editor.getGraph().getNodeMap()[ph.id];
                            placeholder &amp;&amp; placeholder.remove(false);
                        }
                    }
                });
            }
            else {
                toRemove.each(function(id) {
                    var node = editor.getGraph().getNodeMap()[id];
                    node &amp;&amp; node.getGraphics().getHighlightBox &amp;&amp; node.getGraphics().unHighlight();
                });
            }
            return {confirmed: confirmation, affected: nodes, created: placeholders};
        } else {
            editor.getGraph()[&quot;remove&quot; + this.getType()](this);
            nodes[this.getType() + &quot;Nodes&quot;].push(this);
            return {confirmed: true, affected: nodes, created: []};
        }
    },

    &#x2F;**
     * Removes this node and all nodes that will end up disconnected from the
     * Proband as a result. Pushes action onto actionStack.
     *
     * @method removeAction
     *&#x2F;
    removeAction: function() {
        var result = this.remove(true);
        if(result.confirmed) {
            var removed = result.affected,
                placeholders = result.created,
                phPartnerships = [],
                phPregnancies = [];
            placeholders.each(function(ph) {
                var node = editor.getGraph().getNodeMap()[ph.id];
                if(node) {
                    var parentPreg = node.getParentPregnancy();
                    parentPreg &amp;&amp; phPregnancies.push(parentPreg.getInfo());
                    node.getPartnerships().each(function(p) {
                        phPartnerships.push(p.getInfo());
                        p.getPregnancies().each(function(preg) {
                            phPregnancies.push(preg.getInfo());
                        });
                    });
                }
            });
            var undoFunct = function() {
                placeholders.each(function(ph) {
                    var node = editor.getGraph().getNodeMap()[ph.id];
                    node &amp;&amp; node.remove(false);
                });
                removed.PersonNodes.each(function(p) {
                    editor.getGraph().addPerson(p.x, p.y, p.gender, p.id).loadInfo(p);
                });

                removed.PlaceHolderNodes.each(function(p) {
                    editor.getGraph().addPlaceHolder(p.x, p.y, p.gender, p.id).loadInfo(p);
                });

                removed.PersonGroupNodes.each(function(p) {
                    editor.getGraph().addPersonGroup(p.x, p.y, p.id).loadInfo(p);
                });

                removed.PartnershipNodes.each(function(p) {
                    var p1 = editor.getGraph().getNodeMap()[p.partner1ID];
                    var p2 = editor.getGraph().getNodeMap()[p.partner2ID];
                    if(p1 &amp;&amp; p2)
                        editor.getGraph().addPartnership(p.x, p.y, p1, p2, p.id).loadInfo(p);
                });

                removed.PregnancyNodes.each(function(p) {
                    var partnership = editor.getGraph().getNodeMap()[p.partnershipID];
                    if(partnership)
                        editor.getGraph().addPregnancy(p.x, p.y, partnership, p.id).loadInfo(p);
                });
            };

            var redoFunct = function() {
                removed.PregnancyNodes.each(function(p) {
                    var node = editor.getGraph().getNodeMap()[p.id];
                    node &amp;&amp; node.remove(false);
                });

                removed.PartnershipNodes.each(function(p) {
                    var node = editor.getGraph().getNodeMap()[p.id];
                    node &amp;&amp; node.remove(false);
                });

                removed.PersonGroupNodes.each(function(p) {
                    var node = editor.getGraph().getNodeMap()[p.id];
                    node &amp;&amp; node.remove(false);
                });

                removed.PlaceHolderNodes.each(function(p) {
                    var node = editor.getGraph().getNodeMap()[p.id];
                    node &amp;&amp; node.remove(false);
                });

                removed.PersonNodes.each(function(p) {
                    var node = editor.getGraph().getNodeMap()[p.id];
                    node &amp;&amp; node.remove(false);
                });

                placeholders.each(function(p) {
                    editor.getGraph().addPlaceHolder(p.x, p.y, p.gender, p.id).loadInfo(p);
                });

                phPartnerships.each(function(p) {
                    var p1 = editor.getGraph().getNodeMap()[p.partner1ID];
                    var p2 = editor.getGraph().getNodeMap()[p.partner2ID];
                    if(p1 &amp;&amp; p2) {
                        editor.getGraph().addPartnership(p.x, p.y, p1, p2, p.id).loadInfo(p);
                    }
                });

                phPregnancies.each(function(p) {
                    var partnership = editor.getGraph().getNodeMap()[p.partnershipID];
                    if(partnership) {
                        var preg = editor.getGraph().addPregnancy(p.x, p.y, partnership, p.id).loadInfo(p);
                        p.childrenIDs.each(function(id){
                            var child = editor.getGraph().getNodeMap()[id].loadInfo(p);
                            child &amp;&amp; preg.addChild(child);
                        });
                    }
                });
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct});
        }
    },

    &#x2F;**
     * Returns true if this node is related to the node with the id nodeID
     *
     * @method isRelatedTo
     * @param {Number} nodeID ID of any node in the graph
     * @param {Array} [visited=[]] A list of IDs of nodes that shouldn&#x27;t be considered
     * @return {Array} An array in the form of [result, visitedNodes]
     * @example
     var malePerson = editor.getGraph().addPerson(100,100, &quot;M&quot;, 20);
     var femalePerson = editor.getGraph().addPerson(300,100, &quot;F&quot;, 21);

     malePerson.isRelatedTo(femalePerson.getID()) &#x2F;&#x2F; -&gt; [false, [20]]
     *&#x2F;
    isRelatedTo: function(nodeID, visited) {
        var visitedNodes = (visited) ? visited : [];
        if(!editor.getGraph().getNodeMap()[nodeID] || visitedNodes.indexOf(this.getID()) &gt;= 0) {
            return [false, visitedNodes];
        }
        visitedNodes.push(this.getID());
        if(nodeID == this.getID()) {
            return [true, visitedNodes];
        }
        else {
            var result = false;
            this.getNeighbors().forEach(function(neighbor) {
                if(visitedNodes.indexOf(neighbor.getID()) &lt; 0) {
                    var isNeighborRelated = neighbor.isRelatedTo(nodeID, visitedNodes);
                    visitedNodes = isNeighborRelated[1];
                    isNeighborRelated[0] &amp;&amp; (result = true);
                }
            });
            return [result, visitedNodes];
        }
    },

    &#x2F;**
     * Returns an object containing all the information about this node.
     *
     * @method getInfo
     * @return {Object} in the form
     *
     {
        type: &#x2F;&#x2F; (type of the node),
        x:  &#x2F;&#x2F; (x coordinate)
        y:  &#x2F;&#x2F; (y coordinate)
        id: &#x2F;&#x2F; id of the node
     }
     *&#x2F;
    getInfo: function() {
        return {type: this.getType(), x: this.getX(), y : this.getY(), id: this.getID()}
    },

    &#x2F;**
     * Applies the properties found in info to this node.
     *
     * @method loadInfo
     * @param info Object in the form
     *
     {
        type: &#x2F;&#x2F; (type of the node),
        x:  &#x2F;&#x2F; (x coordinate)
        y:  &#x2F;&#x2F; (y coordinate)
        id: &#x2F;&#x2F; id of the node
     }
     * @return {Boolean} True if info was successfully loaded
     *&#x2F;
    loadInfo: function(info) {
        if(info &amp;&amp; info.id == this.getID() &amp;&amp; info.type == this.getType()) {
            if(this.getX() != info.x)
                this.setX(info.x, false, null);
            if(this.getY() != info.y)
                this.setY(info.y, false, null);
            return true;
        }
        return false;
    },

    &#x2F;**
     * Applies properties that happen to this node when a widget (such as the menu) is closed.
     *
     * @method onWidgetHide
     *&#x2F;
    onWidgetHide: function() {
        this.getGraphics().getHoverBox() &amp;&amp; this.getGraphics().getHoverBox().onWidgetHide();
    }
});

var ChildlessBehavior = {
    &#x2F;**
     * Returns the childless status of this node
     *
     * @method getChildlessStatus
     * @return {Null|String} null, childless or infertile
     *&#x2F;
    getChildlessStatus: function() {
        return this._childlessStatus;
    },

    &#x2F;**
     * Returns true if the status is either &#x27;infertile&#x27; or &#x27;childless&#x27;
     *
     * @method isValidChildlessStatus
     * @return {Boolean}
     *&#x2F;
    isValidChildlessStatus: function(status) {
        return ((status == &#x27;infertile&#x27; || status == &#x27;childless&#x27;));
    },

    &#x2F;**
     * Returns the reason for this node&#x27;s status of &#x27;infertile&#x27; or &#x27;childless&#x27;
     *
     * @method getChildlessReason
     * @return {String}
     *&#x2F;
    getChildlessReason: function() {
        return this._childlessReason;
    },

    &#x2F;**
     * Changes the reason for this node&#x27;s &#x27;childless&#x27; or &#x27;infertile&#x27; status
     *
     * @method setChildlessReason
     * @param {String} reason Explanation for the condition (eg. &quot;By Choice&quot;, &quot;Vasectomy&quot; etc)
     *&#x2F;
    setChildlessReason: function(reason) {
        if(this.getChildlessStatus() != null) {
            this._childlessReason = reason;
            this.getGraphics().updateChildlessStatusLabel();
        }
    },

    &#x2F;**
     * Changes the reason for this node&#x27;s &#x27;childless&#x27; or &#x27;infertile&#x27; status and updates the action stack
     *
     * @method setChildlessReasonAction
     * @param {String} reason Explanation for the condition (eg. &quot;By Choice&quot;, &quot;Vasectomy&quot; etc)
     *&#x2F;
    setChildlessReasonAction: function(reason) {
        var prevReason = this.getChildlessReason();
        var nodeID = this.getID();
        if(reason != prevReason &amp;&amp; this.getChildlessStatus()) {
            this.setChildlessReason(reason);
            var actionElement = editor.getActionStack().peek();
            if (actionElement.nodeID == nodeID &amp;&amp; actionElement.property == &#x27;ChildlessReason&#x27;) {
                actionElement.newValue = reason;
            } else {
                editor.getActionStack().push({
                    undo: AbstractNode.setPropertyActionUndo,
                    redo: AbstractNode.setPropertyActionRedo,
                    nodeID: nodeID,
                    property: &#x27;ChildlessReason&#x27;,
                    oldValue: prevReason,
                    newValue: reason
                });
            }
        }
    }
};

AbstractNode.setPropertyActionUndo = function(actionElement) {
    var node = editor.getGraph().getNodeMap()[actionElement.nodeID];
    node &amp;&amp; node[&#x27;set&#x27; + actionElement.property](actionElement.oldValue);
};
AbstractNode.setPropertyActionRedo = function(actionElement) {
    var node = editor.getGraph().getNodeMap()[actionElement.nodeID];
    node &amp;&amp; node[&#x27;set&#x27; + actionElement.property](actionElement.newValue);
};
AbstractNode.setPropertyToListActionUndo = function(actionElement) {
    Object.keys(actionElement.oldValues).forEach(function(key) {
        var node = editor.getGraph().getNodeMap()[key];
        node &amp;&amp; node[&#x27;set&#x27; + actionElement.property](actionElement.oldValues[key]);
    });
};
AbstractNode.setPropertyToListActionRedo = function(actionElement) {
    Object.keys(actionElement.newValues).forEach(function(key) {
        var node = editor.getGraph().getNodeMap()[key];
        node &amp;&amp; node[&#x27;set&#x27; + actionElement.property](actionElement.newValues[key]);
    });
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
