<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>pedigree&#x2F;partnership.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AbstractHoverbox.html">AbstractHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/AbstractNode.html">AbstractNode</a></li>
            
                <li><a href="..&#x2F;classes/AbstractNodeVisuals.html">AbstractNodeVisuals</a></li>
            
                <li><a href="..&#x2F;classes/AbstractPerson.html">AbstractPerson</a></li>
            
                <li><a href="..&#x2F;classes/AbstractPersonVisuals.html">AbstractPersonVisuals</a></li>
            
                <li><a href="..&#x2F;classes/ActionStack.html">ActionStack</a></li>
            
                <li><a href="..&#x2F;classes/ClassName.html">ClassName</a></li>
            
                <li><a href="..&#x2F;classes/Graph.html">Graph</a></li>
            
                <li><a href="..&#x2F;classes/GroupHoverbox.html">GroupHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/Legend.html">Legend</a></li>
            
                <li><a href="..&#x2F;classes/NodeMenu.html">NodeMenu</a></li>
            
                <li><a href="..&#x2F;classes/NodetypeSelectionBubble.html">NodetypeSelectionBubble</a></li>
            
                <li><a href="..&#x2F;classes/Partnership.html">Partnership</a></li>
            
                <li><a href="..&#x2F;classes/PartnershipHoverbox.html">PartnershipHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/PartnershipVisuals.html">PartnershipVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PedigreeEditor.html">PedigreeEditor</a></li>
            
                <li><a href="..&#x2F;classes/Person.html">Person</a></li>
            
                <li><a href="..&#x2F;classes/PersonGroup.html">PersonGroup</a></li>
            
                <li><a href="..&#x2F;classes/PersonGroupVisuals.html">PersonGroupVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PersonHoverbox.html">PersonHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/PersonVisuals.html">PersonVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PlaceHolder.html">PlaceHolder</a></li>
            
                <li><a href="..&#x2F;classes/PlaceHolderVisuals.html">PlaceHolderVisuals</a></li>
            
                <li><a href="..&#x2F;classes/Pregnancy.html">Pregnancy</a></li>
            
                <li><a href="..&#x2F;classes/PregnancyVisuals.html">PregnancyVisuals</a></li>
            
                <li><a href="..&#x2F;classes/SaveLoadEngine.html">SaveLoadEngine</a></li>
            
                <li><a href="..&#x2F;classes/SaveLoadIndicator.html">SaveLoadIndicator</a></li>
            
                <li><a href="..&#x2F;classes/Workspace.html">Workspace</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: pedigree&#x2F;partnership.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Partnership is a class that represents the relationship between two AbstractNodes
 * and their children.
 *
 * @class Partnership
 * @constructor
 * @extends AbstractNode
 * @param x the x coordinate at which the partnership junction will be placed
 * @param y the y coordinate at which the partnership junction will be placed
 * @param partner1 an AbstractPerson who&#x27;s one of the partners in the relationship.
 * @param partner2 an AbstractPerson who&#x27;s the other partner in the relationship. The order of partners is irrelevant.
 * @id the unique ID number of this node
 *&#x2F;

var Partnership = Class.create(AbstractNode, {

   initialize: function($super, x, y, partner1, partner2, id) {
       if(partner1.getType() != &#x27;PlaceHolder&#x27; || partner2.getType() != &#x27;PlaceHolder&#x27;) {
           this._partners = [partner1, partner2];
           this._pregnancies = [];
           this._partners[0].addPartnership(this);
           this._partners[1].addPartnership(this);
           this._childlessStatus = null;
           this._childlessReason = &quot;&quot;;
           $super(x, y, id);
           this._type = &#x27;Partnership&#x27;;
       }
   },

    &#x2F;**
     * Generates and returns an instance of PartnershipVisuals
     *
     * @method _generateGraphics
     * @param {Number} x X coordinate of this partnership
     * @param {Number} y Y coordinate of this partnership
     * @return {PartnershipVisuals}
     * @private
     *&#x2F;
    _generateGraphics: function(x, y) {
        return new PartnershipVisuals(this, x, y);
    },

    &#x2F;**
     * Returns an array containing the two partners. Partners are AbstractPerson objects
     *
     * @method getPartners
     * @return {Array}
     *&#x2F;
    getPartners: function() {
        return this._partners;
    },

    &#x2F;**
     * Returns the female partner in the partnership. Returns null if none of the parents are female
     *
     * @method getMother
     * @return {AbstractPerson}
     *&#x2F;
    getMother: function() {
        if(this.getPartners()[0].getGender() == &quot;F&quot;) {
            return this.getPartners()[0];
        }
        else if(this.getPartners()[1].getGender() == &quot;F&quot;) {
            return this.getPartners()[1];
        }
        else {
            return null;
        }
    },

    &#x2F;**
     * Returns the male partner in the partnership. Returns null if none of the parents are male
     *
     * @method getFather
     * @return {AbstractPerson}
     *&#x2F;
    getFather: function() {
        if(this.getPartners()[0].getGender() == &quot;M&quot;) {
            return this.getPartners()[0];
        }
        else if(this.getPartners()[1].getGender() == &quot;M&quot;) {
            return this.getPartners()[1];
        }
        else {
            return null;
        }
    },

    &#x2F;**
     * Returns the partner of someNode if someNode is a partner in this relationship. Otherwise, returns null.
     *
     * @method getPartnerOf
     * @param {AbstractPerson} someNode
     *&#x2F;
    getPartnerOf: function(someNode) {
        var partner = null;
        if(someNode) {
            if(someNode.getID() == this.getPartners()[0].getID()) {
                partner =  this.getPartners()[1];
            }
            else if(someNode.getID() == this.getPartners()[1].getID()) {
                partner = this.getPartners()[0];
            }
        }
        return partner
    },

    &#x2F;**
     * Returns True if someNode is a partner in this relationship.
     *
     * @method contains
     * @param {AbstractNode} someNode
     *&#x2F;
    contains: function(someNode) {
        return (this.getPartners()[0] == someNode || this.getPartners()[1] == someNode);
    },

    &#x2F;**
     * Returns an array of pregnancies stemming from this partnership.
     *
     * @method getPregnancies
     * @return {Array}
     *&#x2F;
    getPregnancies: function() {
        return this._pregnancies;
    },

    &#x2F;**
     * Returns an array of nodes that are children of this partnership
     *
     * @method getChildren
     * @param {String} [type] Filter nodes to the specified type (eg. &quot;PlaceHolder&quot;, &quot;Person&quot;, etc)
     * Multiple types can be passed (eg. getChildren(type1, type2,...,typeN)
     *&#x2F;
    getChildren: function(type) {
        var args = arguments,
            children = [];
        this.getPregnancies().each(function(pregnancy) {
            children = children.concat(pregnancy.getChildren.apply(pregnancy, args));
        });
        return children;
    },

    &#x2F;**
     * Returns true if someNode is a child of this partnership.
     *
     * @method hasChild
     * @param {AbstractPerson} someNode is an AbstractPerson
     * @return {Boolean}
     *&#x2F;
    hasChild: function(someNode) {
        var found = false;
        this.getPregnancies().each(function(pregnancy) {
            if(pregnancy.hasChild(someNode)) {
                found = true;
                throw $break;
            }
        });
        return found;
    },

    &#x2F;**
     * Creates and returns a new Pregnancy for this partnership
     *
     * @method createPregnancy
     * @return {Pregnancy}
     * TODO: use layout algo to generate position for the pregnancy
     *&#x2F;
    createPregnancy: function() {
        &#x2F;&#x2F;var id = this.getID();
        &#x2F;&#x2F;var pos = editor.findPosition({below: id}, [&#x27;pregnancy&#x27;]);
        return editor.getGraph().addPregnancy(this.getX(), this.getY() + PedigreeEditor.attributes.radius * 2, this);
    },

    &#x2F;**
     * Adds pregnancy to list of pregnancies associated with this partnership
     *
     * @method addPregnancy
     * @param {Pregnancy} pregnancy
     *&#x2F;
    addPregnancy: function(pregnancy) {
        if(pregnancy &amp;&amp; pregnancy.getType() == &quot;Pregnancy&quot;) {
            var newPreg = true;
            this.getPregnancies().each(function(preg){
                if(preg.getID() == pregnancy.getID()) {
                    newPreg = false;
                    throw $break;
                }
            });
            newPreg &amp;&amp; this.getPregnancies().push(pregnancy);
        }
    },

    &#x2F;**
     * Removes pregnancy from the list of pregnancies associated with this partnership
     *
     * @method removePregnancy
     * @param {Pregnancy} pregnancy
     *&#x2F;
    removePregnancy: function(pregnancy) {
        this._pregnancies = this._pregnancies.without(pregnancy);
        var p = this.getPartners();
        if(this._pregnancies.length == 0 &amp;&amp; (p[0].getType() == &quot;PlaceHolder&quot; || p[1].getType() == &quot;PlaceHolder&quot;)) {
            this.remove(false);
        }
    },

    &#x2F;**
     * Returns true if this partnership has given pregnancy
     *
     * @method hasPregnancy
     * @param {Pregnancy} pregnancy
     * @return {Boolean}
     *&#x2F;
    hasPregnancy: function(pregnancy) {
        if(pregnancy) {
            for(var i = 0; i&lt;this.getPregnancies().length; i++) {
                if(this.getPregnancies()[i].getID() == pregnancy.getID())
                    return true;
            }
        }
        return false;
    },

    &#x2F;**
     * Creates a new pregnancy and a new child for that pregnancy.
     *
     * @method createChild
     * @param {String} type (eg. &quot;Person&quot;, &quot;PlaceHolder&quot;, etc)
     * @param {String} gender &quot;M&quot;, &quot;F&quot;, or &quot;U&quot;
     * @return {AbstractPerson} The created child
     *&#x2F;
    createChild: function(type, gender) {
        var placeholders = this.getPlaceHolderPregnancies();
        if(placeholders.length != 0) {
            var child = placeholders[0].getChildren(&#x27;PlaceHolder&#x27;)[0].convertTo(type, gender);
            this.getChildlessStatus() &amp;&amp; child.setAdopted(true);
            return child;
        }
        else {
            var pregnancy = this.createPregnancy();
            pregnancy.setGender(gender);
            return pregnancy.createChild(type);
        }
    },

    &#x2F;**
     * Creates child for this partnership and adds action to action stack
     *
     * @method createNodeAction
     * @param {String} type (eg. &quot;Person&quot;, &quot;PlaceHolder&quot;, etc)
     * @param {String} gender &quot;M&quot;, &quot;F&quot;, or &quot;U&quot;
     * @return {AbstractPerson} The created child
     *&#x2F;
    createNodeAction: function(type, gender) {
        var phPregnancyInfo,
            phInfo;
        this.getPregnancies().each(function(p) {
            if(p.isPlaceHolderPregnancy()) {
                phPregnancyInfo = p.getInfo();
                phInfo = p.getChildren()[0].getInfo();
            }
        });

        var child = this.createChild(type, gender);
        if(child &amp;&amp; child.getParentPregnancy()) {
            var childInfo = child.getInfo(),
                nodeID = this.getID(),
                preg = child.getParentPregnancy(),
                pregInfo = (preg ) ? preg.getInfo() : null,
                newPreg = (!phPregnancyInfo || (preg.getID() != phPregnancyInfo.id));

            var undoFunct = function() {
                var me = editor.getGraph().getNodeMap()[nodeID];
                if(me) {
                    var pregnancy = editor.getGraph().getNodeMap()[pregInfo.id]
                    pregnancy &amp;&amp; pregnancy.remove(false);
                    var target = editor.getGraph().getNodeMap()[childInfo.id]
                    target &amp;&amp; target.remove(false);
                    if(!newPreg) {
                        pregnancy = editor.getGraph().addPregnancy(pregInfo.x, pregInfo.y, me, pregInfo.id)
                        var ph = editor.getGraph().addPlaceHolder(phInfo.x, phInfo.y, phInfo, phInfo.id);
                        pregnancy &amp;&amp; pregnancy.addChild(ph);
                    }
                }
            };

            var redoFunct = function() {
                var existingChild = editor.getGraph().getNodeMap()[childInfo.id],
                    me = editor.getGraph().getNodeMap()[nodeID];
                if(me &amp;&amp; !(existingChild)) {
                    var target = editor.getGraph()[&quot;add&quot; + type](childInfo.x, childInfo.y, gender, childInfo.id);
                    var existingPreg = editor.getGraph().getNodeMap()[pregInfo.id];
                    var pregnancy = (existingPreg) ? existingPreg : editor.getGraph().addPregnancy(pregInfo.x, pregInfo.y, me, pregInfo.id);
                    pregnancy.addChild(target);
                    if(!newPreg){
                        var ph = editor.getGraph().getNodeMap()[phInfo.id];
                        ph &amp;&amp; ph.remove(false);
                    }
                }
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct})
        }
        return child;
    },

    &#x2F;**
     * Adds someNode to the list of children of this partnership, and stores this partnership
     * as it&#x27;s parent partnership.
     *
     * @method addChild
     * @param {AbstractPerson} someNode
     * @return {Null|AbstractPerson} The added child or null if child could not be added
     *&#x2F;
    addChild: function(someNode) {
        if(someNode &amp;&amp; this.canBeParentOf(someNode)) {
            var phPregnancies = this.getPlaceHolderPregnancies();
            if(phPregnancies.length != 0) {
                phPregnancies[0].addChild(someNode);
                phPregnancies[0].getChildren(&quot;PlaceHolder&quot;)[0].remove();
            }
            else {
                this.createPregnancy().addChild(someNode);
            }
            return someNode;
        }
        return null;
    },

    &#x2F;**
     * Adds child to this partnership and creates an action stack entry
     *
     * @method addChildAction
     * @param {AbstractPerson} child
     *&#x2F;
    addChildAction: function(child) {
        if(this.addChild(child)) {
            var childID = child.getID(),
                preg = child.getParentPregnancy(),
                pregInfo = preg.getInfo(),
                part = preg.getPartnership().getInfo();

            var redoFunct = function() {
                var source = editor.getGraph().getNodeMap()[part.partnershipID];
                var theChild = editor.getGraph().getNodeMap()[childID];
                if(source &amp;&amp; theChild) {
                    var pregnancy = editor.getGraph().addPregnancy(pregInfo.x, pregInfo.y, source, pregInfo.id);
                    pregnancy.addChild(theChild);
                }
            };
            var undoFunct = function() {
                var pregnancy = editor.getGraph().getNodeMap()[pregInfo.id];
                pregnancy &amp;&amp; pregnancy.remove(false);
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct});
        }
    },

    &#x2F;**
     * Removes someNode from the list of children of this partnership, and removes this partnership as its parents
     * reference. Returns someNode.
     *
     * @method removeChild
     * @param {AbstractPerson} someNode
     *&#x2F;
    removeChild: function(someNode) {
        if(someNode) {
            var pregnancy = someNode.getParentPregnancy();
            if(pregnancy &amp;&amp; this.hasPregnancy(pregnancy))
                pregnancy &amp;&amp; pregnancy.removeChild(someNode);
        }
    },

    &#x2F;**
     * Changes the status of this partnership. Nullifies the status if the given status is not
     * &quot;childless&quot; or &quot;infertile&quot;.
     *
     * @method setChildlessStatus
     * @param {String} status Can be &quot;childless&quot;, &quot;infertile&quot; or null
     * @param {Boolean} ignoreChildren If True, changing the status will not detach any children
     *&#x2F;
    setChildlessStatus: function(status, ignoreChildren) {
        if(status != this.getChildlessStatus()) {
            if(this.isValidChildlessStatus(status)) {
                this._childlessStatus = status;
                if(!ignoreChildren) {
                    this.getChildren(&quot;PlaceHolder&quot;).each(function(child) {
                            child.remove(false);
                    });
                }
            }
            else {
                this._childlessStatus = null;
                !ignoreChildren &amp;&amp; this.restorePlaceholders();
            }
            this.setChildlessReason(null);
            this.getGraphics().updateChildlessShapes();
        }
    },

    &#x2F;**
     * Returns True if this partnership has any children coming from the same pregnancy
     *
     * @method hasTwins
     * @return {boolean}
     *&#x2F;
    hasTwins: function() {
        var pregs = this.getPregnancies();
        for(var i = 0; i &lt; pregs.length; i++) {
            if(pregs[i].getChildren(&quot;Person&quot;).length &gt; 1) {
                return true;
            }
        }
        return false;
    },

    &#x2F;**
     * Returns True if this partnership has any children that are not adopted
     *
     * @method hasNonAdoptedChildren
     * @return {Boolean}
     *&#x2F;
    hasNonAdoptedChildren: function() {
        var pregs = this.getPregnancies();
        for(var i = 0; i &lt; pregs.length; i++) {
            if(pregs[i].hasNonAdoptedChildren())
                return true;
        }
        return false;
    },

    &#x2F;**
     * Removes this partnership and all the visuals attached to it from the graph.
     *
     * @method remove
     * @param [$super]
     * @param {Boolean} isRecursive Set to True to remove all pregnancies and children, unless they have some other
     * connection to the Proband
     * @param {Boolean} skipConfirmation If True, will not display a confirmation dialogue
     *&#x2F;
    remove: function($super, isRecursive, skipConfirmation) {
        if(isRecursive) {
            return $super(isRecursive, skipConfirmation);
        }
        else {
            this.getPregnancies().each(function(pregnancy) {
                pregnancy.remove();
            });
            var p1 = this.getPartners()[0];
            var p2 = this.getPartners()[1];
            p1.removePartnership(this);
            p2.removePartnership(this);
            p1.getType() == &quot;PlaceHolder&quot; &amp;&amp; p1.remove(false);
            p2.getType() == &quot;PlaceHolder&quot; &amp;&amp; p2.remove(false);
            this.getGraphics().remove();
            return $super(false);
        }
    },

    &#x2F;**
     * Returns an array of all adjacent nodes (neighbors) located below this node.
     *
     * @method getLowerNeighbors
     * @return {Array} in the form of [node1, node2, ...]
     *&#x2F;
    getLowerNeighbors: function($super) {
        return $super().concat(this.getPregnancies());
    },

    &#x2F;**
     * Returns the partners in this partnership.
     *
     * @method getSideNeighbors
     * @return {Array} In the form of [node1, node2]
     *&#x2F;
    getSideNeighbors: function() {
        return this.getPartners();
    },

    &#x2F;**
     * Returns True if someNode can be a child of this partnership
     *
     * @method canBeParentOf
     * @param {AbstractPerson} someNode
     * @return {Boolean}
     *&#x2F;
    canBeParentOf: function(someNode) {
        return (this.getPartners()[0].canBeParentOf(someNode) &amp;&amp; this.getPartners()[1].canBeParentOf(someNode));
    },

    &#x2F;**
     * Creates a placeholder child for this partnership, if it has no children
     *
     * @method restorePlaceholders
     *&#x2F;
    restorePlaceholders: function() {
        if(!this.getPartners()[0].getChildlessStatus() &amp;&amp;
           !this.getPartners()[1].getChildlessStatus() &amp;&amp;
            this.getChildren().length == 0) {
            this.createChild(&#x27;PlaceHolder&#x27;, &#x27;U&#x27;)
        }
    },

    &#x2F;**
     * Returns a list of pregnancies with only a PlaceHolder child.
     *
     * @method getPlaceHolderPregnancies
     * @return {Array} Array of Pregnancy objects
     *&#x2F;
    getPlaceHolderPregnancies: function() {
        var pregnancies = [];
        this.getPregnancies().each(function(pregnancy) {
            pregnancy.isPlaceHolderPregnancy() &amp;&amp; pregnancies.push(pregnancy);
        });
        return pregnancies;
    },

    &#x2F;**
     * Returns an object (to be accepted by the menu) with information about this Partnership
     *
     * @method getSummary
     * @return {Object}
     *&#x2F;
    getSummary: function() {
        var childlessInactive = this.hasNonAdoptedChildren();
        return {
            identifier:    {value : this.getID()},
            childlessSelect : {value : this.getChildlessStatus() ? this.getChildlessStatus() : &#x27;none&#x27;, inactive: childlessInactive},
            childlessText : {value : this.getChildlessReason() ? this.getChildlessReason() : &#x27;none&#x27;, inactive: childlessInactive}
        };
    },

    &#x2F;**
     * Returns object with serialization data for this Partnership
     *
     * @method getInfo
     * @param [$super]
     * @return {Object}
     *&#x2F;
    getInfo: function($super) {
        var info = $super();
        info[&#x27;partner1ID&#x27;] = this.getPartners()[0].getID();
        info[&#x27;partner2ID&#x27;] = this.getPartners()[1].getID();
        info[&#x27;childlessStatus&#x27;] = this.getChildlessStatus();
        info[&#x27;childlessReason&#x27;] = this.getChildlessReason();
        return info;
    },

    &#x2F;**
     * Applies properties found in info to this Partnership
     *
     * @method loadInfo
     * @param [$super]
     * @param info Serialization data
     * @return {boolean} Returns true if data in info was successfully applied to this node
     *&#x2F;
    loadInfo: function($super, info) {
        if($super(info)) {
            if(info.childlessStatus &amp;&amp; info.childlessStatus != this.getChildlessStatus()) {
                this.setChildlessStatus(info.childlessStatus);
            }
            if(info.childlessReason &amp;&amp; info.childlessReason != this.getChildlessReason()) {
                this.setChildlessReason(info.childlessReason);
            }
            return true;
        }
        return false;
    },

    &#x2F;**
     * Changes the status of this partnership. Nullifies the status if the given status is not
     * &quot;childless&quot; or &quot;infertile&quot;. Adds an action stack entry for this action.
     *
     * @method setChildlessStatus
     * @param {String} status Can be &quot;childless&quot;, &quot;infertile&quot; or null
     *&#x2F;
    setChildlessStatusAction: function(status) {
        if(status != this.getChildlessStatus() &amp;&amp; (status || this.getChildlessStatus())) {
            var me = this,
                nodeID = this.getID(),
                prevStatus = this.getChildlessStatus(),
                prevReason = this.getChildlessReason();
            var getPhInfo = function() {
                var preg = me.getPregnancies()[0],
                    ph = preg ? preg.getChildren(&quot;PlaceHolder&quot;)[0] : null;
                return {
                    pregInfo: (preg &amp;&amp; preg.isPlaceHolderPregnancy()) ? preg.getInfo() : null,
                    childInfo: ph ? ph.getInfo() : null
                }
            };
            var nodesBeforeChange = getPhInfo(); &#x2F;&#x2F;PlaceHolder child and pregnancy before changing childlessStatus
            this.setChildlessStatus(status, false);
            var nodesAfterChange = getPhInfo(); &#x2F;&#x2F;PlaceHolder child and pregnancy after changing childlessStatus

            editor.getActionStack().push({
                undo: Partnership.childlessActionUndo,
                redo: Partnership.childlessActionRedo,
                nodeID: nodeID,
                status: status,
                prevStatus: prevStatus,
                prevReason: prevReason,
                nodesBeforeChange: nodesBeforeChange,
                nodesAfterChange: nodesAfterChange
            });
        }
    },

    &#x2F;**
     * Changes the reason for this Partnership&#x27;s childlessStatus. Adds an entry in the action stack for this action.
     *
     * @method setChildlessReasonAction
     * @param {String} reason
     *&#x2F;
    setChildlessReasonAction: function(reason) {
        var nodeID = this.getID();
        var prevReason = this.getChildlessReason();
        this.setChildlessReason(reason);
        var undo = function() {
            var partnership = editor.getGraph().getNodeMap()[nodeID];
            partnership &amp;&amp; partnership.setChildlessReason(prevReason);
        };
        var redo = function() {
            var partnership = editor.getGraph().getNodeMap()[nodeID];
            partnership &amp;&amp; partnership.setChildlessReason(reason);
        };
        editor.getActionStack().push({undo: undo, redo: redo});
    }
});

&#x2F;&#x2F;ATTACH CHILDLESS BEHAVIOR METHODS TO PARTNERSHIP OBJECTS
Partnership.addMethods(ChildlessBehavior);

&#x2F;&#x2F;HELPERS FOR CHILDLESS-RELATED METHODS
Partnership.removeNodes = function(nodes) {
    Object.keys(nodes).forEach(function(key) {
        if(nodes[key]) {
            var node = editor.getGraph().getNodeMap()[nodes[key].id];
            node &amp;&amp; node.remove(false);
        }
    });
};

Partnership.restoreNodes = function(nodes, partnership) {
    if(nodes.pregInfo) {
        var pregnancy = editor.getGraph().addPregnancy(nodes.pregInfo.x, nodes.pregInfo.y, partnership, nodes.pregInfo.id);
        if(nodes.childInfo) {
            var child = editor.getGraph().addPlaceHolder(nodes.childInfo.x, nodes.childInfo.y, &quot;U&quot;, nodes.childInfo.id);
            pregnancy.addChild(child);
        }
    }
};

Partnership.childlessActionUndo = function(actionElement) {
    var partnership = editor.getGraph().getNodeMap()[actionElement.nodeID];
    if(partnership) {
        Partnership.removeNodes(actionElement.nodesAfterChange);
        partnership.setChildlessStatus(actionElement.prevStatus, true);
        partnership.setChildlessReason(actionElement.prevReason);
        Partnership.restoreNodes(actionElement.nodesBeforeChange, partnership)
    }
};
Partnership.childlessActionRedo = function(actionElement) {
    var partnership = editor.getGraph().getNodeMap()[actionElement.nodeID];
    if(partnership) {
        Partnership.removeNodes(actionElement.nodesBeforeChange);
        partnership.setChildlessStatus(actionElement.status, true);
        Partnership.restoreNodes(actionElement.nodesAfterChange, partnership)
    }
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
