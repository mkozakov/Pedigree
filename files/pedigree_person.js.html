<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>pedigree&#x2F;person.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AbstractHoverbox.html">AbstractHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/AbstractNode.html">AbstractNode</a></li>
            
                <li><a href="..&#x2F;classes/AbstractNodeVisuals.html">AbstractNodeVisuals</a></li>
            
                <li><a href="..&#x2F;classes/AbstractPerson.html">AbstractPerson</a></li>
            
                <li><a href="..&#x2F;classes/AbstractPersonVisuals.html">AbstractPersonVisuals</a></li>
            
                <li><a href="..&#x2F;classes/ActionStack.html">ActionStack</a></li>
            
                <li><a href="..&#x2F;classes/ClassName.html">ClassName</a></li>
            
                <li><a href="..&#x2F;classes/Graph.html">Graph</a></li>
            
                <li><a href="..&#x2F;classes/GroupHoverbox.html">GroupHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/Legend.html">Legend</a></li>
            
                <li><a href="..&#x2F;classes/NodeMenu.html">NodeMenu</a></li>
            
                <li><a href="..&#x2F;classes/NodetypeSelectionBubble.html">NodetypeSelectionBubble</a></li>
            
                <li><a href="..&#x2F;classes/Partnership.html">Partnership</a></li>
            
                <li><a href="..&#x2F;classes/PartnershipHoverbox.html">PartnershipHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/PartnershipVisuals.html">PartnershipVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PedigreeEditor.html">PedigreeEditor</a></li>
            
                <li><a href="..&#x2F;classes/Person.html">Person</a></li>
            
                <li><a href="..&#x2F;classes/PersonGroup.html">PersonGroup</a></li>
            
                <li><a href="..&#x2F;classes/PersonGroupVisuals.html">PersonGroupVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PersonHoverbox.html">PersonHoverbox</a></li>
            
                <li><a href="..&#x2F;classes/PersonVisuals.html">PersonVisuals</a></li>
            
                <li><a href="..&#x2F;classes/PlaceHolder.html">PlaceHolder</a></li>
            
                <li><a href="..&#x2F;classes/PlaceHolderVisuals.html">PlaceHolderVisuals</a></li>
            
                <li><a href="..&#x2F;classes/Pregnancy.html">Pregnancy</a></li>
            
                <li><a href="..&#x2F;classes/PregnancyVisuals.html">PregnancyVisuals</a></li>
            
                <li><a href="..&#x2F;classes/SaveLoadEngine.html">SaveLoadEngine</a></li>
            
                <li><a href="..&#x2F;classes/SaveLoadIndicator.html">SaveLoadIndicator</a></li>
            
                <li><a href="..&#x2F;classes/Workspace.html">Workspace</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: pedigree&#x2F;person.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Person is a class representing any AbstractPerson that has sufficient information to be
 * displayed on the final pedigree graph (printed or exported). Person objects
 * contain information about disorders, age and other relevant properties, as well
 * as graphical data to visualize this information.
 *
 * @class Person
 * @constructor
 * @extends AbstractPerson
 * @param {Number} x X coordinate on the Raphael canvas at which the node drawing will be centered
 * @param {Number} y Y coordinate on the Raphael canvas at which the node drawing will be centered
 * @param {String} gender &#x27;M&#x27;, &#x27;F&#x27; or &#x27;U&#x27; depending on the gender
 * @param {Number} id Unique ID number
 * @param {Boolean} isProband True if this person is the proband
 *&#x2F;

var Person = Class.create(AbstractPerson, {

    initialize: function($super, x, y, gender, id) {
        this._firstName = &quot;&quot;;
        this._lastName = &quot;&quot;;
        this._birthDate = &quot;&quot;;
        this._deathDate = &quot;&quot;;
        this._conceptionDate = &quot;&quot;;
        this._isAdopted = false;
        this._lifeStatus = &#x27;alive&#x27;;
        this._isProband = (id == 1);
        this._childlessStatus = null;
        this._childlessReason = &quot;&quot;;
        this._disorders = [];
        this._evaluations = [];
        this._type = &quot;Person&quot;;
        $super(x, y, gender, id);
    },

    &#x2F;**
     * Initializes the object responsible for creating graphics for this Person
     *
     * @method _generateGraphics
     * @param {Number} x X coordinate on the Raphael canvas at which the node drawing will be centered
     * @param {Number} y Y coordinate on the Raphael canvas at which the node drawing will be centered
     * @return {PersonVisuals}
     * @private
     *&#x2F;
    _generateGraphics: function(x, y) {
        return new PersonVisuals(this, x, y);
    },

    &#x2F;**
     * Returns True if this node is the proband (i.e. the main patient)
     *
     * @method isProband
     * @return {Boolean}
     *&#x2F;
    isProband: function() {
        return this._isProband;
    },

    &#x2F;**
     * Creates a new partnership between this Person and partner
     *
     * @method addPartner
     * @param [$super]
     * @param {AbstractPerson} partner
     * @param {Boolean} [noChild=false] Set to True if the partnership should not have a PlaceHolder child
     * @return {Partnership}
     *&#x2F;
    addPartner: function($super, partner, noChild) {
        noChild || (noChild = false); &#x2F;&#x2F;default value
        var partnership = $super(partner, noChild);
        if(partnership) {
            var status = partner.getType() == &quot;Person&quot; &amp;&amp; partner.getChildlessStatus();
            !status &amp;&amp; (status = this.getChildlessStatus());
            partnership.setChildlessStatus(status);
        }
        return partnership;
    },

    &#x2F;**
     * Creates a Partnership with a new Placeholder and adds a new Person child to this Partnership. Adds
     * entry in the action stack for this action.
     *
     * @method createNodeAction
     * @param {String} type The type for the new child. (eg. &quot;Person&quot;, &quot;PlaceHolder&quot;, &quot;PersonGroup&quot;)
     * @param {String} gender &quot;M&quot;, &quot;F&quot; or &quot;U&quot;.
     * @return {AbstractPerson} The created partner
     *&#x2F;
    createNodeAction: function(type, gender) {
        var child = this.createChild(type, gender);
        var childless = this.getChildlessStatus();

        if(child &amp;&amp; child.getParentPregnancy()) {
            var childInfo = child.getInfo(),
                nodeID = this.getID(),
                preg = child.getParentPregnancy(),
                pregInfo = preg ? preg.getInfo() : null,
                part = preg.getPartnership(),
                partInfo = part.getInfo(),
                partnerInfo = part.getPartnerOf(this).getInfo();

            var undoFunct = function() {
                var pregnancy = editor.getGraph().getNodeMap()[pregInfo.id];
                pregnancy &amp;&amp; pregnancy.remove(false);
                var partnership = editor.getGraph().getNodeMap()[partInfo.id];
                partnership &amp;&amp; partnership.remove(false);
                var partner = editor.getGraph().getNodeMap()[partnerInfo.id];
                partner &amp;&amp; partner.remove(false);
                var target = editor.getGraph().getNodeMap()[childInfo.id];
                target &amp;&amp; target.remove(false);
            };

            var redoFunct = function() {
                var existingChild = editor.getGraph().getNodeMap()[childInfo.id],
                    existingPreg = editor.getGraph().getNodeMap()[pregInfo.id],
                    existingPart = editor.getGraph().getNodeMap()[partInfo.id],
                    existingPartner = editor.getGraph().getNodeMap()[partnerInfo.id],
                    me = editor.getGraph().getNodeMap()[nodeID];
                if(me &amp;&amp; !(existingChild || existingPreg || existingPart || existingPartner )) {
                    var target = editor.getGraph()[&quot;add&quot; + type](childInfo.x, childInfo.y, gender, childInfo.id);
                    var partner = editor.getGraph().addPlaceHolder(partnerInfo.x, partnerInfo.y, gender, partnerInfo.id);
                    var partnership = editor.getGraph().addPartnership(partInfo.x, partInfo.y, me, partner, partInfo.id);
                    var pregnancy = editor.getGraph().addPregnancy(pregInfo.x, pregInfo.y, partnership, pregInfo.id);
                    pregnancy.addChild(target);
                    childless &amp;&amp; partnership.setChildlessStatus(childless);
                }
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct})
        }
        return child;
    },

    &#x2F;**
     * Creates a new partnership with a new Person node. Creates an action stack entry
     * for the action.
     *
     * @method createPartnerAction
     * @return {Null|Person} The newly created partner. Null in case partner could not be created.
     *&#x2F;
    createPartnerAction: function() {
        var partnership = this.createPartner(false);
        if(partnership){
            var nodeID = this.getID(),
                part = partnership.getInfo(),
                partner = partnership.getPartnerOf(this).getInfo(),
                preg = (partnership.getPregnancies()[0]) ? partnership.getPregnancies()[0].getInfo() : null,
                ph = preg ? partnership.getPregnancies()[0].getChildren()[0].getInfo() : null;

            var redoFunct = function() {
                var source = editor.getGraph().getNodeMap()[nodeID];
                if(source) {
                    var person = editor.getGraph().addPerson(partner.x, partner.y, partner.gender, partner.id);
                    var newPartnership = editor.getGraph().addPartnership(part.x, part.y, source, person, part.id);
                    if(preg) {
                        var pr = editor.getGraph().addPregnancy(preg.x, preg.y, newPartnership, preg.id);
                        var child = editor.getGraph().addPlaceHolder(ph.x, ph.y, ph.gender, ph.id);
                        pr.addChild(child);
                    }
                    newPartnership.setChildlessStatus(part.childlessStatus);
                }
            };

            var undoFunct = function() {
                if(preg) {
                    var placeholder = editor.getGraph().getNodeMap()[ph.id];
                    placeholder &amp;&amp; placeholder.remove(false);
                }
                var thePartner = editor.getGraph().getNodeMap()[partner.id];
                thePartner &amp;&amp; thePartner.remove(false);
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct})
            return partnership.getPartnerOf(this);
        }
        return null;
    },

    &#x2F;**
     * Creates a new partnership with a new Person node and returns the partner. Creates an action stack entry
     * for the action.
     *
     * @method addPartnerAction
     * @return {Null|Person} The added partner. Null in case the partnership could not be created
     *&#x2F;
    addPartnerAction: function(partner) {
        var partnership = this.addPartner(partner);
        if(partnership) {
            var part = partnership.getInfo(),
                preg = (partnership.getPregnancies()[0]) ? partnership.getPregnancies()[0].getInfo() : null,
                ph = preg ? partnership.getPregnancies()[0].getChildren()[0].getInfo() : null,
                nodeID = this.getID(),
                partnerID = partner.getID();

            var redoFunct = function() {
                var source = editor.getGraph().getNodeMap()[nodeID];
                var person = editor.getGraph().getNodeMap()[partnerID];
                if(source &amp;&amp; person) {
                    var p = editor.getGraph().addPartnership(part.x, part.y, source, person, part.id);
                    if(preg) {
                        var pr = editor.getGraph().addPregnancy(preg.x, preg.y, p, preg.id);
                        var child = editor.getGraph().addPlaceHolder(ph.x, ph.y, ph.gender, ph.id);
                        pr.addChild(child);
                    }
                    p.setChildlessStatus(part.childlessStatus)
                }
            };

            var undoFunct = function() {
                if(preg) {
                    var placeHolder = editor.getGraph().getNodeMap()[ph.id];
                    placeHolder &amp;&amp; placeHolder.remove(false);
                }
                var partner = editor.getGraph().getNodeMap()[part.id];
                partner &amp;&amp; partner.remove(false);
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct})
            return partnership.getPartnerOf(this);
        }
        return null;
    },

    &#x2F;**
     * Makes child the child of this Person. Creates an action stack entry for the action.
     *
     * @method addChildAction
     * @return {Null|Person} The added child. Null if the child could not be added
     *&#x2F;
    addChildAction: function(child) {
        if(child = this.addChild(child)) {
            var childID = child.getID(),
                nodeID = this.getID(),
                p = child.getParentPregnancy(),
                pa = p.getPartnership(),
                preg = p.getInfo(),
                part = pa.getInfo(),
                parent = pa.getPartnerOf(this).getInfo();

            var redoFunct = function() {
                var source = editor.getGraph().getNodeMap()[nodeID];
                var theChild = editor.getGraph().getNodeMap()[childID];
                if(source &amp;&amp; theChild) {
                    var ph = editor.getGraph().addPlaceHolder(parent.x, parent.y, parent.gender, parent.id);
                    var partnership = editor.getGraph().addPartnership(part.x, part.y, source, ph, part.id);
                    var pregnancy = editor.getGraph().addPregnancy(preg.x, preg.y, partnership, preg.id);
                    pregnancy.addChild(theChild);
                }
            };
            var undoFunct = function() {
                var partnership = editor.getGraph().getNodeMap()[part.id];
                partnership &amp;&amp; partnership.remove(false);
                var par = editor.getGraph().getNodeMap()[parent.id];
                par &amp;&amp; par.remove(false);
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct});
        }
        return child;
    },

    &#x2F;**
     * Creates a set of parents for this Person. Adds an action stack entry for the action
     *
     * @method createParentsAction
     * @return {Null|Partnership} The partnership between the new parent nodes. Null if parents could not be added
     *&#x2F;
    createParentsAction: function() {
        var partnership;
        if(partnership = this.createParents()) {
            var nodeID = this.getID(),
                part = partnership.getInfo(),
                preg = partnership.getPregnancies()[0].getInfo(),
                parent1 = partnership.getPartners()[0].getInfo(),
                parent2 = partnership.getPartners()[1].getInfo();

            var redoFunct = function() {
                var child = editor.getGraph().getNodeMap()[nodeID];
                if(child) {
                    var par1 = editor.getGraph().addPerson(parent1.x, parent1.y, parent1.gender, parent1.id);
                    var par2 = editor.getGraph().addPerson(parent2.x, parent2.y, parent2.gender, parent2.id);
                    var partn = editor.getGraph().addPartnership(part.x, part.y, par1, par2, part.id);
                    var pregnancy = editor.getGraph().addPregnancy(preg.x, preg.y, partn, preg.id);
                    pregnancy.addChild(child);
                }
            };
            var undoFunct = function() {
                var par1 = editor.getGraph().getNodeMap()[parent1.id];
                var par2 = editor.getGraph().getNodeMap()[parent2.id];
                var partn = editor.getGraph().getNodeMap()[part.id];
                partn &amp;&amp; partn.remove(false);
                par1 &amp;&amp; par1.remove(false);
                par2 &amp;&amp; par2.remove(false);
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct})
        }
        return partnership;
    },

    &#x2F;**
     * Sets partnership as this Person&#x27;s parent partnership
     *
     * @method addParents
     * @param [$super]
     * @param {Partnership} partnership
     * @return {Null|Partnership} The added partnership or null if it couldn&#x27;t be added
     *&#x2F;
    addParents: function($super, partnership) {
        var returnValue = $super(partnership);
        partnership.getChildlessStatus() &amp;&amp; this.setAdopted(true);
        return returnValue;
    },

    &#x2F;**
     * Sets partnership as this Person&#x27;s parent partnership. Creates entry in action stack for the action.
     *
     * @method addParentsAction
     * @param {Partnership} partnership
     * @return {Null|Partnership} The added partnership or null if it couldn&#x27;t be added
     *&#x2F;
    addParentsAction: function(partnership) {
        var parentPartnership;
        if(parentPartnership = this.addParents(partnership)) {
            var nodeID = this.getID(),
                partID = partnership.getID(),
                preg = this.getParentPregnancy().getInfo();

            var redoFunct = function() {
                var child = editor.getGraph().getNodeMap()[nodeID];
                var partn  = editor.getGraph().getNodeMap()[partID];
                if(child &amp;&amp; partn) {
                    var pregnancy = editor.getGraph().addPregnancy(preg.x, preg.y, partn, preg.id);
                    pregnancy.addChild(child);
                }
            };
            var undoFunct = function() {
                var pregnancy = editor.getGraph().getNodeMap()[preg.id];
                pregnancy &amp;&amp; pregnancy.remove();
            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct})
        }
        return parentPartnership;
    },

    &#x2F;**
     * Sets parent as this Person&#x27;s parent. Creates entry in action stack for the action.
     *
     * @method addParentAction
     * @param {AbstractPerson} parent
     * @return {Null|Partnership} The parent partnership or null if parent couldn&#x27;t be added
     *&#x2F;
    addParentAction: function(parent) {
        var partnership;
        if(partnership = this.addParent(parent)) {
            var parentID = parent.getID(),
                nodeID = this.getID(),
                part = partnership.getInfo(),
                partner = partnership.getPartnerOf(parent).getInfo(),
                preg = partnership.getPregnancies()[0].getInfo();

            var redoFunct = function() {
                var child = editor.getGraph().getNodeMap()[nodeID];
                var par = editor.getGraph().getNodeMap()[parentID];
                if(child &amp;&amp; par) {
                    var ph =  editor.getGraph().addPlaceHolder(partner.x, partner.y, partner.gender, partner.id);
                    var partnership = editor.getGraph().addPartnership(part.x, part.y, par, ph, part.id);
                    var pregnancy = editor.getGraph().addPregnancy(preg.x, preg.y, partnership, preg.id);
                    pregnancy.addChild(child);
                }
            };
            var undoFunct = function() {
                var partnership = editor.getGraph().getNodeMap()[part.id];
                partnership &amp;&amp; partnership.remove();
                var ph = editor.getGraph().getNodeMap()[partner.id];
                ph &amp;&amp; ph.remove(false);

            };
            editor.getActionStack().push({undo: undoFunct, redo: redoFunct});
        }
        return partnership;
    },

    &#x2F;**
     * Adds a new partnership to the list of partnerships of this node
     *
     * @method addPartnership
     * @param [$super]
     * @param {Partnership} partnership Partnership with this node as one of the partners
     * @return {null|Partnership} The added Partnership or null if it couldn&#x27;t be added
     *&#x2F;
    addPartnership: function($super, partnership) {
        this.getGraphics().getHoverBox().hideChildHandle();
        return $super(partnership);
    },

    &#x2F;**
     * Removes partnership from the list of partnerships
     *
     * @method removePartnership
     * @param [$super]
     * @param {Partnership} partnership Partnership with this node as one of the partners
     *&#x2F;
    removePartnership: function($super, partnership) {
        this.getGraphics().getHoverBox().unhideChildHandle();
        return $super(partnership);
    },

    &#x2F;**
     * Replaces the parent Pregnancy
     *
     * @method setParentPregnancy
     * @param [$super]
     * @param {Pregnancy} pregnancy
     *&#x2F;
    setParentPregnancy: function($super, pregnancy) {
        $super(pregnancy);
        if(pregnancy) {
            this.getGraphics().getHoverBox().hideParentHandle();
        }
        else {
            this.getGraphics().getHoverBox().unHideParentHandle();
        }
    },

    &#x2F;**
     * Returns the first name of this Person
     *
     * @method getFirstName
     * @return {String}
     *&#x2F;
    getFirstName: function() {
        return this._firstName;
    },

    &#x2F;**
     * Replaces the first name of this Person with firstName, and displays the label
     *
     * @method setFirstName
     * @param firstName
     *&#x2F;
    setFirstName: function(firstName) {
        firstName &amp;&amp; (firstName = firstName.charAt(0).toUpperCase() + firstName.slice(1));
        this._firstName = firstName;
        this.getGraphics().updateNameLabel();
    },

    &#x2F;**
     * Replaces the first name of this Person with firstName, and displays the label. Creates an entry in action stack.
     *
     * @method setFirstNameAction
     * @param {String} firstName
     *&#x2F;
    setFirstNameAction: function(firstName) {
        var oldName = this.getFirstName();
        var nodeID = this.getID();
        this.setFirstName(firstName);
        var actionElement = editor.getActionStack().peek();
        if (actionElement &amp;&amp; actionElement.nodeID == nodeID &amp;&amp; actionElement.property == &#x27;FirstName&#x27;) {
            actionElement.newValue = firstName;
        } else {
            editor.getActionStack().push({
                undo: AbstractNode.setPropertyActionUndo,
                redo: AbstractNode.setPropertyActionRedo,
                nodeID: nodeID,
                property: &#x27;FirstName&#x27;,
                oldValue: oldName,
                newValue: firstName
            });
        }
    },

    &#x2F;**
     * Returns the last name of this Person
     *
     * @method getLastName
     * @return {String}
     *&#x2F;
    getLastName: function() {
        return this._lastName;
    },

    &#x2F;**
     * Replaces the last name of this Person with lastName, and displays the label
     *
     * @method setLastName
     * @param lastName
     *&#x2F;
    setLastName: function(lastName) {
        lastName &amp;&amp; (lastName = lastName.charAt(0).toUpperCase() + lastName.slice(1));
        this._lastName = lastName;
        this.getGraphics().updateNameLabel();
        return lastName;
    },

    &#x2F;**
     * Replaces the last name of this Person with lastName, and displays the label. Creates an entry in action stack.
     *
     * @method setLastName
     * @param lastName
     *&#x2F;
    setLastNameAction: function(lastName) {
        var oldName = this.getLastName();
        var nodeID = this.getID();
        this.setLastName(lastName);
        var actionElement = editor.getActionStack().peek();
        if (actionElement &amp;&amp; actionElement.nodeID == nodeID &amp;&amp; actionElement.property == &#x27;LastName&#x27;) {
            actionElement.newValue = lastName;
        } else {
            editor.getActionStack().push({
                undo: AbstractNode.setPropertyActionUndo,
                redo: AbstractNode.setPropertyActionRedo,
                nodeID: nodeID,
                property: &#x27;LastName&#x27;,
                oldValue: oldName,
                newValue: lastName
            });
        }
        return lastName;
    },

    &#x2F;**
     * Returns the status of this Person
     *
     * @method getLifeStatus
     * @return {String} &quot;alive&quot;, &quot;deceased&quot;, &quot;stillborn&quot;, &quot;unborn&quot; or &quot;aborted&quot;
     *&#x2F;
    getLifeStatus: function() {
        return this._lifeStatus;
    },

    &#x2F;**
     * Returns True if this node&#x27;s status is not &#x27;alive&#x27; or &#x27;deceased&#x27;.
     *
     * @method isFetus
     * @return {Boolean}
     *&#x2F;
    isFetus: function() {
        return (this.getLifeStatus() != &#x27;alive&#x27; &amp;&amp; this.getLifeStatus() != &#x27;deceased&#x27;);
    },

    &#x2F;**
     * Returns True is status is &#x27;unborn&#x27;, &#x27;stillborn&#x27;, &#x27;aborted&#x27;, &#x27;alive&#x27; or &#x27;deceased&#x27;
     *
     * @method _isValidLifeStatus
     * @param {String} status
     * @returns {boolean}
     * @private
     *&#x2F;
    _isValidLifeStatus: function(status) {
        return (status == &#x27;unborn&#x27; || status == &#x27;stillborn&#x27;
            || status == &#x27;aborted&#x27;
            || status == &#x27;alive&#x27; || status == &#x27;deceased&#x27;)
    },

    &#x2F;**
     * Changes the life status of this Person to newStatus
     *
     * @method setLifeStatus
     * @param {String} newStatus &quot;alive&quot;, &quot;deceased&quot;, &quot;stillborn&quot;, &quot;unborn&quot; or &quot;aborted&quot;
     *&#x2F;
    setLifeStatus: function(newStatus) {
        if(this._isValidLifeStatus(newStatus)) {
            this._lifeStatus = newStatus;

            (newStatus != &#x27;deceased&#x27;) &amp;&amp; this.setDeathDate(&quot;&quot;);
            this.getGraphics().updateSBLabel();

            if(this.isFetus()) {
                this.setBirthDate(&quot;&quot;);
                this.setAdopted(false);
                this.setChildlessStatus(null);
            }
            this.getGraphics().updateLifeStatusShapes();
            editor.getNodeMenu().update(this,
                {
                    &#x27;gestation_age&#x27;: {value : this.getGestationAge(), inactive : !this.isFetus()},
                    &#x27;date_of_birth&#x27;: {value : this.getBirthDate(), inactive : this.isFetus()},
                    &#x27;adopted&#x27;:       {value : this.isAdopted(), inactive: this.isFetus()},
                    &#x27;date_of_death&#x27;: {value : this.getDeathDate(), inactive: newStatus != &#x27;deceased&#x27;},
                    childlessSelect : {value : this.getChildlessStatus() ? this.getChildlessStatus() : &#x27;none&#x27;, inactive : this.isFetus()},
                    childlessText : {value : this.getChildlessReason() ? this.getChildlessReason() : &#x27;none&#x27;, inactive : this.isFetus()}
                });
        }
    },

    &#x2F;**
     * Changes the life status of this Person to newStatus and creates an entry in action stack.
     *
     * @method setLifeStatusAction
     * @param {String} newStatus &quot;alive&quot;, &quot;deceased&quot;, &quot;stillborn&quot;, &quot;unborn&quot; or &quot;aborted&quot;
     *&#x2F;
    setLifeStatusAction: function(newStatus) {
        var prevStatus = this.getLifeStatus();
        var nodeID = this.getID();
        if(prevStatus != newStatus &amp;&amp; this._isValidLifeStatus(newStatus)) {
            this.setLifeStatus(newStatus);
            editor.getActionStack().push({
                undo: AbstractNode.setPropertyActionUndo,
                redo: AbstractNode.setPropertyActionRedo,
                nodeID: nodeID,
                property: &#x27;LifeStatus&#x27;,
                oldValue: prevStatus,
                newValue: newStatus
            });
        }
    },

    &#x2F;**
     * Returns the date of the conception date of this Person
     *
     * @method getConceptionDate
     * @return {Date}
     *&#x2F;
    getConceptionDate: function() {
        return this._conceptionDate;
    },

    &#x2F;**
     * Replaces the conception date with newDate
     *
     * @method setConceptionDate
     * @param {Date} newDate Date of conception
     *&#x2F;
    setConceptionDate: function(newDate) {
        this._conceptionDate = newDate ? (new Date(newDate)) : &#x27;&#x27;;
        this.getGraphics().updateAgeLabel();
    },

    &#x2F;**
     * Returns the number of weeks since conception
     *
     * @method getGestationAge
     * @return {Number}
     *&#x2F;
    getGestationAge: function() {
        if(this.getLifeStatus() == &#x27;unborn&#x27; &amp;&amp; this.getConceptionDate()) {
            var oneWeek = 1000 * 60 * 60 * 24 * 7,
                lastDay = new Date();
            return Math.round((lastDay.getTime() - this.getConceptionDate().getTime()) &#x2F; oneWeek)
        }
        else if(this.isFetus()){
            return this._gestationAge;
        }
        else {
            return null;
        }
    },

    &#x2F;**
     * Updates the conception age of the Person given the number of weeks passed since conception
     *
     * @method setGestationAge
     * @param {Number} numWeeks Greater than or equal to 0
     *&#x2F;
    setGestationAge: function(numWeeks) {
        if(numWeeks){
            this._gestationAge = numWeeks;
            var daysAgo = numWeeks * 7,
                d = new Date();
            d.setDate(d.getDate() - daysAgo);
            this.setConceptionDate(d);
        }
        else {
            this.setConceptionDate(null);
        }
    },

    &#x2F;**
     * Updates the conception age of the Person given the number of weeks passed since conception.
     * Creates entry in action stack
     *
     * @method setGestationAgeAction
     * @param {Number} numWeeks Greater than or equal to 0
     *&#x2F;
    setGestationAgeAction: function(numWeeks) {
        var oldDate = this.getGestationAge();
        var nodeID = this.getID();
        if(oldDate != numWeeks) {
            this.setGestationAge(numWeeks);
            editor.getActionStack().push({
                undo: AbstractNode.setPropertyActionUndo,
                redo: AbstractNode.setPropertyActionRedo,
                nodeID: nodeID,
                property: &#x27;GestationAge&#x27;,
                oldValue: oldDate,
                newValue: numWeeks
            });
        }
    },

    &#x2F;**
     * Returns the the birth date of this Person
     *
     * @method getBirthDate
     * @return {Date}
     *&#x2F;
    getBirthDate: function() {
        return this._birthDate;
    },

    &#x2F;**
     * Replaces the birth date with newDate
     *
     * @method setBirthDate
     * @param {Date} newDate Must be earlier date than deathDate and a later than conception date
     *&#x2F;
    setBirthDate: function(newDate) {
        newDate = newDate ? (new Date(newDate)) : &#x27;&#x27;;
        if (!newDate || newDate &amp;&amp; !this.getDeathDate() || newDate.getDate() &lt; this.getDeathDate()) {
            this._birthDate = newDate;
            this.getGraphics().updateAgeLabel();
        }
    },

    &#x2F;**
     * Replaces the birth date with newDate
     * Creates entry in action stack
     *
     * @method setBirthDate
     * @param {Date} newDate Must be earlier date than deathDate and a later than conception date
     *&#x2F;
    setBirthDateAction: function(newDate) {
        var oldDate = this.getBirthDate();
        var nodeID = this.getID();
        if(oldDate != newDate) {
            this.setBirthDate(newDate);
            editor.getActionStack().push({
                undo: AbstractNode.setPropertyActionUndo,
                redo: AbstractNode.setPropertyActionRedo,
                nodeID: nodeID,
                property: &#x27;BirthDate&#x27;,
                oldValue: oldDate,
                newValue: newDate
            });
        }
    },

    &#x2F;**
     * Returns the death date of this Person
     *
     * @method getDeathDate
     * @return {Date}
     *&#x2F;
    getDeathDate: function() {
        return this._deathDate;
    },

    &#x2F;**
     * Replaces the death date with deathDate
     *
     *
     * @method setDeathDate
     * @param {Date} deathDate Must be a later date than birthDate
     *&#x2F;
    setDeathDate: function(deathDate) {
        deathDate = deathDate ? (new Date(deathDate)) : &#x27;&#x27;;
        if(!deathDate || deathDate &amp;&amp; !this.getBirthDate() || deathDate.getDate()&gt;this.getBirthDate().getDate()) {
            this._deathDate =  deathDate;
            this._deathDate &amp;&amp; (this.getLifeStatus() == &#x27;alive&#x27;) &amp;&amp; this.setLifeStatus(&#x27;deceased&#x27;);
        }
        this.getGraphics().updateAgeLabel();
        return this.getDeathDate();
    },

    &#x2F;**
     * Replaces the death date with newDate
     * Creates entry in action stack
     *
     * @method setDeathDate
     * @param {Date} newDate Must be a later date than birthDate
     *&#x2F;
    setDeathDateAction: function(newDate) {
        var oldDate = this.getDeathDate();
        var nodeID = this.getID();
        if(oldDate != newDate) {
            this.setDeathDate(newDate);
            editor.getActionStack().push({
                undo: AbstractNode.setPropertyActionUndo,
                redo: AbstractNode.setPropertyActionRedo,
                nodeID: nodeID,
                property: &#x27;DeathDate&#x27;,
                oldValue: oldDate,
                newValue: newDate
            });
        }
    },

    &#x2F;**
     * Returns a list of disorders of this person.
     *
     * @method getDisorders
     * @return {Array} List of Disorder objects.
     *&#x2F;
    getDisorders: function() {
        return this._disorders;
    },

    &#x2F;**
     * Adds disorder to the list of this node&#x27;s disorders and updates the Legend.
     *
     * @method addDisorder
     * @param {Disorder} disorder Disorder object
     * @param [forceDisplay] True if you want to display the change on the canvas
     *&#x2F;
    addDisorder: function(disorder, forceDisplay) {
        if(!this.getDisorderByID(disorder.getDisorderID())) {
            editor.getLegend().addCase(disorder.getDisorderID(), disorder.getName(), this.getID());
            this.getDisorders().push(disorder);
        }
        forceDisplay &amp;&amp; this.getGraphics().updateDisorderShapes();
    },

    &#x2F;**
     * Adds disorder to the list of this node&#x27;s disorders and updates the Legend.
     * Creates entry in action stack.
     *
     * @method addDisorderAction
     * @param {Disorder} disorder
     *&#x2F;
    addDisorderAction: function(disorder) {
        if(!this.getDisorderByID(disorder.getDisorderID())) {
            var nodeID = this.getID();
            this.addDisorder(disorder, true);
            editor.getActionStack().push({
                undo: function() {
                    var node = editor.getGraph().getNodeMap()[nodeID];
                    node &amp;&amp; node.removeDisorder(disorder, true);
                },
                redo: function() {
                    var node = editor.getGraph().getNodeMap()[nodeID];
                    node &amp;&amp; node.addDisorder(disorder, true);
                }
            })
        }
    },

    &#x2F;**
     * Removes disorder to the list of this node&#x27;s disorders and updates the Legend.
     *
     * @method removeDisorder
     * @param {Disorder} disorder
     * @param forceDisplay True if you want to display the change on the canvas
     *&#x2F;
    removeDisorder: function(disorder, forceDisplay) {
        var personsDisorder = null;
        if(personsDisorder = this.getDisorderByID(disorder.getDisorderID())) {
            editor.getLegend().removeCase(disorder.getDisorderID(), this.getID());
            this._disorders = this.getDisorders().without(personsDisorder);
        }
        else {
            alert(&quot;This person doesn&#x27;t have the specified disorder&quot;);
        }
        forceDisplay &amp;&amp; this.getGraphics().updateDisorderShapes();
    },

    &#x2F;**
     * Given a list of disorders, adds and removes the disorders of this node to match
     * the new list
     *
     * @method setDisorders
     * @param {Array} disorders List of Disorder objects
     *&#x2F;
    setDisorders: function(disorders) {
        var me = this;
        this.getDisorders().each(function(disorder) {
            var found = false;
            disorders.each(function(newDisorder) {
                disorder.getDisorderID() == newDisorder.getDisorderID() &amp;&amp; (found = true);
            });
            !found &amp;&amp; me.removeDisorder(disorder, false);
        });
        disorders.each(function(newDisorder) {
            if (!me.getDisorderByID(newDisorder.getDisorderID())) {
                me.addDisorder(newDisorder);
            }
        });
        this.getGraphics().updateDisorderShapes();
    },

    &#x2F;**
     * Given a list of disorders, adds and removes the disorders of this node to match
     * the new list. Adds entry in action stack.
     *
     * @method setDisorders
     * @param {Array} disorders List of Disorder objects
     *&#x2F;
    setDisordersAction: function(disorders) {
        var prevDisorders = this.getDisorders().clone();
        var nodeID = this.getID();
        this.setDisorders(disorders);
        editor.getActionStack().push({
            undo: AbstractNode.setPropertyActionUndo,
            redo: AbstractNode.setPropertyActionRedo,
            nodeID: nodeID,
            property: &#x27;Disorders&#x27;,
            oldValue: prevDisorders,
            newValue: disorders
        });
    },

    &#x2F;**
     * Returns disorder with given id if this person has it. Returns null otherwise.
     *
     * @method getDisorderByID
     * @param {Number} id Disorder ID, taken from the OMIM database
     * @return {Disorder}
     *&#x2F;
    getDisorderByID: function(id) {
        for(var i = 0; i &lt; this.getDisorders().length; i++) {
            if(this.getDisorders()[i].getDisorderID() == id) {
                return this.getDisorders()[i];
            }
        }
        return null;
    },

    &#x2F;**
     * Returns True if this Person can be a parent of otherNode
     *
     * @method canBeParentOf
     * @param [$super]
     * @param {Person} otherNode
     * @return {Boolean}
     *&#x2F;
    canBeParentOf: function($super, otherNode) {
        var preliminary = $super(otherNode);
        if(otherNode.getBirthDate) {
            var incompatibleBirthDate = this.getBirthDate() &amp;&amp; otherNode.getBirthDate() &amp;&amp; this.getBirthDate() &lt; otherNode.getBirthDate();
            var incompatibleDeathDate = this.getDeathDate() &amp;&amp; otherNode.getBirthDate() &amp;&amp; this.getDeathDate() &lt; otherNode.getBirthDate().clone().setDate(otherNode.getBirthDate().getDate()-700);
        }
        return preliminary &amp;&amp; !incompatibleBirthDate &amp;&amp; !incompatibleDeathDate &amp;&amp; !this.isFetus();
    },

    &#x2F;**
     * Replaces this Person with a placeholder without breaking any the connections.
     *
     * @method convertToPlaceholder
     * @return {PlaceHolder}
     *&#x2F;
    convertToPlaceholder: function() {
        var me = this;
        var gender = (this.getPartnerships().length == 0) ? &quot;U&quot; : this.getGender();
        var placeholder = editor.getGraph().addPlaceHolder(this.getX(), this.getY(), this.getGender());
        var parents = this.getUpperNeighbors()[0];
        if(parents) {
            parents.addChild(placeholder);
            parents.removeChild(me);
            placeholder.setGender(gender);
        }
        this.getPartnerships().each(function(partnership) {
            var newPartnership = editor.getGraph().addPartnership(partnership.getX(), partnership.getY(), partnership.getPartnerOf(me), placeholder);
            partnership.getChildren().each(function(child) {
                partnership.removeChild(child);
                newPartnership.addChild(child);
            });
        });
        me.remove(false);
        return placeholder;
    },

    &#x2F;**
     * Changes the childless status of this Person. Nullifies the status if the given status is not
     * &quot;childless&quot; or &quot;infertile&quot;. Modifies the status of the partnerships as well.
     *
     * @method setChildlessStatus
     * @param {String} status Can be &quot;childless&quot;, &quot;infertile&quot; or null
     * @param {Boolean} ignoreOthers If True, changing the status will not modify partnerships&#x27;s statuses or
     * detach any children
     *&#x2F;
    setChildlessStatus: function(status, ignoreOthers) {
        if(!this.isValidChildlessStatus(status))
            status = null;
        if(status != this.getChildlessStatus()) {
            this._childlessStatus = status;
            this.setChildlessReason(null);
            this.getGraphics().updateChildlessShapes();
            if(!ignoreOthers) {
                this.getPartnerships().each(function(partnership) {
                    if(!partnership.getChildlessReason())
                        partnership.setChildlessStatus(status);
                });
            }
        }
        return this.getChildlessStatus();
    },

    &#x2F;**
     * Changes the childless status of this Person. Nullifies the status if the given status is not
     * &quot;childless&quot; or &quot;infertile&quot;. Modifies the status of the partnerships as well.
     * Creates a an entry in action stack.
     *
     * @method setChildlessStatusAction
     * @param {String} status Can be &quot;childless&quot;, &quot;infertile&quot; or null
     *&#x2F;
    setChildlessStatusAction: function(status) {
        if(status != this.getChildlessStatus()) {
            var me = this;
            var prevStatus = this.getChildlessStatus();
            var nodeID = this.getID();
            var markerID = editor.getActionStack().pushStartMarker();

            this.getPartnerships().each(function(partnership) {
                partnership.setChildlessStatusAction(status);
            });

            this.setChildlessStatus(status, true);
            var undo = function() {
                var node = editor.getGraph().getNodeMap()[nodeID];
                    node &amp;&amp; node.setChildlessStatus(prevStatus, true);
            };

            var redo = function() {
                var node = editor.getGraph().getNodeMap()[nodeID];
                node &amp;&amp; node.setChildlessStatus(status, true);
            };
            editor.getActionStack().push({undo: undo, redo: redo});
            editor.getActionStack().pushEndMarker(markerID);
        }
        return this.getChildlessStatus();
    },

    &#x2F;**
     * Deletes this node, it&#x27;s placeholder partners and children and optionally
     * removes all the other nodes that are unrelated to the proband node.
     *
     * @method remove
     * @param [$super]
     * @param {Boolean} isRecursive set to true if you want to remove related nodes that are
     * not connected to the proband
     * @param {Boolean} skipConfirmation If True, will not display confirmation alert box
     * @return {Object} in the form
     *
     {
        confirmed: true&#x2F;false,
        affected: {
            PersonNodes : [Person1, Person2, ...],
            PartnershipNodes : [Partnership1, Partnership2, ...],
            PregnancyNodes : [Pregnancy1, Pregnancy2, ...],
            PersonGroupNodes : [PersonGroup1, PersonGroup2, ...],
            PlaceHolderNodes : [PlaceHolder1, PlaceHolder2, ...]
        },
        created: [PlaceHolder1, PlaceHolder2, ...]
     }
     *&#x2F;
    remove: function($super, isRecursive, skipConfirmation) {
        var me = this;
        if(!isRecursive) {
            this.getPartners().each(function(partner) {
                if(partner.getType() == &#x27;PlaceHolder&#x27;) {
                    partner.remove(false);
                }
            });
            var parents = this.getParentPartnership();
            var singleChild = parents &amp;&amp; parents.getChildren().length == 1;
            var hasChildren = this.getChildren(&quot;Person&quot;).concat(this.getChildren(&quot;PersonGroup&quot;)).length != 0;
            var hasTwoKnownParents = parents &amp;&amp; parents.getPartners()[0].getType() == &quot;Person&quot; &amp;&amp; parents.getPartners()[1].getType() == &quot;Person&quot;;
            var childlessParents = parents &amp;&amp; parents.getChildlessStatus();
            if(hasTwoKnownParents &amp;&amp; singleChild &amp;&amp; !childlessParents || hasChildren) {
                var phInfo = this.convertToPlaceholder().getInfo();
                var returnValue = $super(isRecursive, skipConfirmation);
                returnValue.created &amp;&amp; returnValue.created.push(phInfo);
                return returnValue;
            }
            else {
                this.getDisorders().each(function(disorder) {
                    editor.getLegend().removeCase(disorder.getDisorderID(), me.getID());
                });
                this.getGraphics().getHoverBox().remove();
                return $super(isRecursive, skipConfirmation);
            }
        }
        else {
            return $super(isRecursive, skipConfirmation);
        }
    },

    &#x2F;**
     * Adds a placeholder child to all partnerships that are missing it.
     *
     * @method restorePlaceholders
     *&#x2F;
    restorePlaceholders: function() {
        var me = this;
        this.getPartnerships().each(function(partnership) {
            if(!me.getChildlessStatus() &amp;&amp; !partnership.getChildlessStatus() &amp;&amp;
                !partnership.getPartnerOf(me).getChildlessStatus() &amp;&amp;
                partnership.getChildren().length == 0) {
                partnership.createChild(&#x27;PlaceHolder&#x27;, &#x27;U&#x27;)
            }
        });
    },

    &#x2F;**
     * Returns an object (to be accepted by the menu) with information about this Person
     *
     * @method getSummary
     * @return {Object} Summary object for the menu
     *&#x2F;
    getSummary: function() {
        var childlessInactive = this.isFetus() || this.hasNonAdoptedChildren();
        var disorders = [];
        this.getDisorders().forEach(function(disorder) {
            disorders.push({id: disorder.getDisorderID(), value: disorder.getName()});
        });
        return {
            identifier:    {value : this.getID()},
            first_name:    {value : this.getFirstName()},
            last_name:     {value : this.getLastName()},
            gender:        {value : this.getGender(), inactive: (this.getGender() != &#x27;U&#x27; &amp;&amp; this.getPartners().length &gt; 0)},
            date_of_birth: {value : this.getBirthDate(), inactive: this.isFetus()},
            disorders:     {value : disorders},
            adopted:       {value : this.isAdopted(), inactive: (this.isFetus() || (this.getParentPartnership() &amp;&amp; this.getParentPartnership().getChildren(&quot;Person&quot;).length &gt; 1))},
            state:         {value : this.getLifeStatus(), inactive: [(this.getPartnerships().length &gt; 0) ? [&#x27;unborn&#x27;,&#x27;aborted&#x27;,&#x27;stillborn&#x27;] : &#x27;&#x27;].flatten()},
            date_of_death: {value : this.getDeathDate(), inactive: this.getLifeStatus() != &#x27;deceased&#x27;},
            gestation_age: {value : this.getGestationAge(), inactive : !this.isFetus()},
            childlessSelect : {value : this.getChildlessStatus() ? this.getChildlessStatus() : &#x27;none&#x27;, inactive : childlessInactive},
            childlessText : {value : this.getChildlessReason() ? this.getChildlessReason() : undefined, inactive : childlessInactive, disabled : !this.getChildlessStatus()}
        };
    },

    &#x2F;**
     * Returns object with serialization data
     *
     * @method getInfo
     * @param [$super]
     * @return {Object}
     *&#x2F;
    getInfo: function($super) {
        var info = $super();
        info[&#x27;fName&#x27;] = this.getFirstName();
        info[&#x27;lName&#x27;] = this.getLastName();
        info[&#x27;dob&#x27;] = this.getBirthDate();
        info[&#x27;isAdopted&#x27;] = this.isAdopted();
        info[&#x27;lifeStatus&#x27;] = this.getLifeStatus();
        info[&#x27;dod&#x27;] = this.getDeathDate();
        info[&#x27;gestationAge&#x27;] = this.getGestationAge();
        info[&#x27;childlessStatus&#x27;] = this.getChildlessStatus();
        info[&#x27;childlessReason&#x27;] = this.getChildlessReason();
        info[&#x27;disorders&#x27;] = [];
        this.getDisorders().forEach(function(disorder) {
            info[&#x27;disorders&#x27;].push({id: disorder.getDisorderID(), name: disorder.getName()})
        });
        return info;
     },

    &#x2F;**
     * Applies properties found in info to this Person
     *
     * @method loadInfo
     * @param [$super]
     * @param info Serialization data object
     *&#x2F;
    loadInfo: function($super, info) {
        if($super(info)) {
            if(info.fName &amp;&amp; this.getFirstName() != info.fName) {
                this.setFirstName(info.fName);
            }
            if(info.lName &amp;&amp; this.getLastName() != info.lName) {
                this.setLastName(info.lName);
            }
            if(info.dob &amp;&amp; this.getBirthDate() != info.dob) {
                this.setBirthDate(info.dob);
            }
            if(info.disorders) {
                var disorders = [];
                info.disorders.forEach(function(disorder) {
                    disorders.push(new Disorder(disorder.id, disorder.name))
                });
                this.setDisorders(disorders);
            }
            if(info.isAdopted &amp;&amp; this.isAdopted() != info.isAdopted) {
                this.setAdopted(info.isAdopted);
            }
            if(info.lifeStatus &amp;&amp; this.getLifeStatus() != info.lifeStatus) {
                this.setLifeStatus(info.lifeStatus);
            }
            if(info.dod &amp;&amp; this.getDeathDate() != info.dod) {
                this.setDeathDate(info.dod);
            }
            if(info.gestationAge &amp;&amp; this.getGestationAge() != info.gestationAge) {
                this.setGestationAge(info.gestationAge);
            }
            if(info.childlessStatus &amp;&amp; this.getChildlessStatus() != info.childlessStatus) {
                this.setChildlessStatus(info.childlessStatus);
            }
            if(info.childlessReason &amp;&amp; this.getChildlessReason() != info.childlessReason) {
                this.setChildlessReason(info.childlessReason);
            }
        }
    }
});

&#x2F;&#x2F;ATTACHES CHILDLESS BEHAVIOR METHODS TO THIS CLASS
Person.addMethods(ChildlessBehavior);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
